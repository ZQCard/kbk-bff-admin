// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: admin/v1/admin.proto

package admin

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LoginReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReqMultiError, or nil
// if none found.
func (m *LoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 4 || l > 20 {
		err := LoginReqValidationError{
			field:  "Username",
			reason: "value length must be between 4 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LoginReq_Username_Pattern.MatchString(m.GetUsername()) {
		err := LoginReqValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{3,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 6 {
		err := LoginReqValidationError{
			field:  "Password",
			reason: "value length must be at least 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginReqMultiError(errors)
	}

	return nil
}

// LoginReqMultiError is an error wrapping multiple validation errors returned
// by LoginReq.ValidateAll() if the designated constraints aren't met.
type LoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReqMultiError) AllErrors() []error { return m }

// LoginReqValidationError is the validation error returned by
// LoginReq.Validate if the designated constraints aren't met.
type LoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReqValidationError) ErrorName() string { return "LoginReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReqValidationError{}

var _LoginReq_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{3,15}$")

// Validate checks the field values on LoginRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResMultiError, or nil
// if none found.
func (m *LoginRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return LoginResMultiError(errors)
	}

	return nil
}

// LoginResMultiError is an error wrapping multiple validation errors returned
// by LoginRes.ValidateAll() if the designated constraints aren't met.
type LoginResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResMultiError) AllErrors() []error { return m }

// LoginResValidationError is the validation error returned by
// LoginRes.Validate if the designated constraints aren't met.
type LoginResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResValidationError) ErrorName() string { return "LoginResValidationError" }

// Error satisfies the builtin error interface
func (e LoginResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResValidationError{}

// Validate checks the field values on Administrator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Administrator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Administrator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AdministratorMultiError, or
// nil if none found.
func (m *Administrator) ValidateAll() error {
	return m.validate(true)
}

func (m *Administrator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Username

	// no validation rules for Mobile

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Status

	// no validation rules for Role

	// no validation rules for LastLoginTime

	// no validation rules for LastLoginIp

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	if len(errors) > 0 {
		return AdministratorMultiError(errors)
	}

	return nil
}

// AdministratorMultiError is an error wrapping multiple validation errors
// returned by Administrator.ValidateAll() if the designated constraints
// aren't met.
type AdministratorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdministratorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdministratorMultiError) AllErrors() []error { return m }

// AdministratorValidationError is the validation error returned by
// Administrator.Validate if the designated constraints aren't met.
type AdministratorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdministratorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdministratorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdministratorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdministratorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdministratorValidationError) ErrorName() string { return "AdministratorValidationError" }

// Error satisfies the builtin error interface
func (e AdministratorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdministrator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdministratorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdministratorValidationError{}

// Validate checks the field values on GetAdministratorListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAdministratorListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAdministratorListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAdministratorListReqMultiError, or nil if none found.
func (m *GetAdministratorListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAdministratorListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() <= 0 {
		err := GetAdministratorListReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() <= 0 {
		err := GetAdministratorListReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Username

	// no validation rules for Mobile

	// no validation rules for Nickname

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAdministratorListReqValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAdministratorListReqValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAdministratorListReqValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedAtStart

	// no validation rules for CreatedAtEnd

	if len(errors) > 0 {
		return GetAdministratorListReqMultiError(errors)
	}

	return nil
}

// GetAdministratorListReqMultiError is an error wrapping multiple validation
// errors returned by GetAdministratorListReq.ValidateAll() if the designated
// constraints aren't met.
type GetAdministratorListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAdministratorListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAdministratorListReqMultiError) AllErrors() []error { return m }

// GetAdministratorListReqValidationError is the validation error returned by
// GetAdministratorListReq.Validate if the designated constraints aren't met.
type GetAdministratorListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAdministratorListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAdministratorListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAdministratorListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAdministratorListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAdministratorListReqValidationError) ErrorName() string {
	return "GetAdministratorListReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetAdministratorListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAdministratorListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAdministratorListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAdministratorListReqValidationError{}

// Validate checks the field values on GetAdministratorListPageRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAdministratorListPageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAdministratorListPageRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAdministratorListPageResMultiError, or nil if none found.
func (m *GetAdministratorListPageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAdministratorListPageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAdministratorListPageResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAdministratorListPageResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAdministratorListPageResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAdministratorListPageResMultiError(errors)
	}

	return nil
}

// GetAdministratorListPageResMultiError is an error wrapping multiple
// validation errors returned by GetAdministratorListPageRes.ValidateAll() if
// the designated constraints aren't met.
type GetAdministratorListPageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAdministratorListPageResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAdministratorListPageResMultiError) AllErrors() []error { return m }

// GetAdministratorListPageResValidationError is the validation error returned
// by GetAdministratorListPageRes.Validate if the designated constraints
// aren't met.
type GetAdministratorListPageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAdministratorListPageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAdministratorListPageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAdministratorListPageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAdministratorListPageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAdministratorListPageResValidationError) ErrorName() string {
	return "GetAdministratorListPageResValidationError"
}

// Error satisfies the builtin error interface
func (e GetAdministratorListPageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAdministratorListPageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAdministratorListPageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAdministratorListPageResValidationError{}

// Validate checks the field values on CreateAdministratorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAdministratorReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAdministratorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAdministratorReqMultiError, or nil if none found.
func (m *CreateAdministratorReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAdministratorReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 4 || l > 20 {
		err := CreateAdministratorReqValidationError{
			field:  "Username",
			reason: "value length must be between 4 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateAdministratorReq_Username_Pattern.MatchString(m.GetUsername()) {
		err := CreateAdministratorReqValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{3,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 6 {
		err := CreateAdministratorReqValidationError{
			field:  "Password",
			reason: "value length must be at least 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateAdministratorReq_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := CreateAdministratorReqValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNickname()); l < 1 || l > 20 {
		err := CreateAdministratorReqValidationError{
			field:  "Nickname",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAvatar()); l < 1 || l > 255 {
		err := CreateAdministratorReqValidationError{
			field:  "Avatar",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	if len(m.GetRole()) < 1 {
		err := CreateAdministratorReqValidationError{
			field:  "Role",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateAdministratorReqMultiError(errors)
	}

	return nil
}

// CreateAdministratorReqMultiError is an error wrapping multiple validation
// errors returned by CreateAdministratorReq.ValidateAll() if the designated
// constraints aren't met.
type CreateAdministratorReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAdministratorReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAdministratorReqMultiError) AllErrors() []error { return m }

// CreateAdministratorReqValidationError is the validation error returned by
// CreateAdministratorReq.Validate if the designated constraints aren't met.
type CreateAdministratorReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAdministratorReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAdministratorReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAdministratorReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAdministratorReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAdministratorReqValidationError) ErrorName() string {
	return "CreateAdministratorReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAdministratorReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAdministratorReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAdministratorReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAdministratorReqValidationError{}

var _CreateAdministratorReq_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{3,15}$")

var _CreateAdministratorReq_Mobile_Pattern = regexp.MustCompile("^1[0-9]{10}$")

// Validate checks the field values on UpdateAdministratorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAdministratorReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAdministratorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateAdministratorReqMultiError, or nil if none found.
func (m *UpdateAdministratorReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAdministratorReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateAdministratorReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUsername()); l < 4 || l > 20 {
		err := UpdateAdministratorReqValidationError{
			field:  "Username",
			reason: "value length must be between 4 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateAdministratorReq_Username_Pattern.MatchString(m.GetUsername()) {
		err := UpdateAdministratorReqValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{3,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 6 {
		err := UpdateAdministratorReqValidationError{
			field:  "Password",
			reason: "value length must be at least 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateAdministratorReq_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := UpdateAdministratorReqValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1[0-9]{10}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetNickname()); l < 1 || l > 20 {
		err := UpdateAdministratorReqValidationError{
			field:  "Nickname",
			reason: "value length must be between 1 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAvatar()); l < 1 || l > 255 {
		err := UpdateAdministratorReqValidationError{
			field:  "Avatar",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	if len(m.GetRole()) < 1 {
		err := UpdateAdministratorReqValidationError{
			field:  "Role",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateAdministratorReqMultiError(errors)
	}

	return nil
}

// UpdateAdministratorReqMultiError is an error wrapping multiple validation
// errors returned by UpdateAdministratorReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateAdministratorReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAdministratorReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAdministratorReqMultiError) AllErrors() []error { return m }

// UpdateAdministratorReqValidationError is the validation error returned by
// UpdateAdministratorReq.Validate if the designated constraints aren't met.
type UpdateAdministratorReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAdministratorReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAdministratorReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAdministratorReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAdministratorReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAdministratorReqValidationError) ErrorName() string {
	return "UpdateAdministratorReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAdministratorReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAdministratorReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAdministratorReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAdministratorReqValidationError{}

var _UpdateAdministratorReq_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{3,15}$")

var _UpdateAdministratorReq_Mobile_Pattern = regexp.MustCompile("^1[0-9]{10}$")

// Validate checks the field values on IdReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IdReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IdReqMultiError, or nil if none found.
func (m *IdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *IdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return IdReqMultiError(errors)
	}

	return nil
}

// IdReqMultiError is an error wrapping multiple validation errors returned by
// IdReq.ValidateAll() if the designated constraints aren't met.
type IdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IdReqMultiError) AllErrors() []error { return m }

// IdReqValidationError is the validation error returned by IdReq.Validate if
// the designated constraints aren't met.
type IdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IdReqValidationError) ErrorName() string { return "IdReqValidationError" }

// Error satisfies the builtin error interface
func (e IdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IdReqValidationError{}

// Validate checks the field values on CheckResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CheckResponseMultiError, or
// nil if none found.
func (m *CheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return CheckResponseMultiError(errors)
	}

	return nil
}

// CheckResponseMultiError is an error wrapping multiple validation errors
// returned by CheckResponse.ValidateAll() if the designated constraints
// aren't met.
type CheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckResponseMultiError) AllErrors() []error { return m }

// CheckResponseValidationError is the validation error returned by
// CheckResponse.Validate if the designated constraints aren't met.
type CheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckResponseValidationError) ErrorName() string { return "CheckResponseValidationError" }

// Error satisfies the builtin error interface
func (e CheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckResponseValidationError{}

// Validate checks the field values on GetRoleAllRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetRoleAllRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleAllRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetRoleAllResMultiError, or
// nil if none found.
func (m *GetRoleAllRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleAllRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetRoleAllResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetRoleAllResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetRoleAllResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetRoleAllResMultiError(errors)
	}

	return nil
}

// GetRoleAllResMultiError is an error wrapping multiple validation errors
// returned by GetRoleAllRes.ValidateAll() if the designated constraints
// aren't met.
type GetRoleAllResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleAllResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleAllResMultiError) AllErrors() []error { return m }

// GetRoleAllResValidationError is the validation error returned by
// GetRoleAllRes.Validate if the designated constraints aren't met.
type GetRoleAllResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleAllResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleAllResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleAllResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleAllResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleAllResValidationError) ErrorName() string { return "GetRoleAllResValidationError" }

// Error satisfies the builtin error interface
func (e GetRoleAllResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleAllRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleAllResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleAllResValidationError{}

// Validate checks the field values on Role with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Role) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Role with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoleMultiError, or nil if none found.
func (m *Role) ValidateAll() error {
	return m.validate(true)
}

func (m *Role) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return RoleMultiError(errors)
	}

	return nil
}

// RoleMultiError is an error wrapping multiple validation errors returned by
// Role.ValidateAll() if the designated constraints aren't met.
type RoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleMultiError) AllErrors() []error { return m }

// RoleValidationError is the validation error returned by Role.Validate if the
// designated constraints aren't met.
type RoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleValidationError) ErrorName() string { return "RoleValidationError" }

// Error satisfies the builtin error interface
func (e RoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleValidationError{}

// Validate checks the field values on CreateRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateRoleReqMultiError, or
// nil if none found.
func (m *CreateRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateRoleReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateRoleReqMultiError(errors)
	}

	return nil
}

// CreateRoleReqMultiError is an error wrapping multiple validation errors
// returned by CreateRoleReq.ValidateAll() if the designated constraints
// aren't met.
type CreateRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRoleReqMultiError) AllErrors() []error { return m }

// CreateRoleReqValidationError is the validation error returned by
// CreateRoleReq.Validate if the designated constraints aren't met.
type CreateRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRoleReqValidationError) ErrorName() string { return "CreateRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRoleReqValidationError{}

// Validate checks the field values on UpdateRoleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRoleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRoleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateRoleReqMultiError, or
// nil if none found.
func (m *UpdateRoleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRoleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRoleReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := UpdateRoleReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateRoleReqMultiError(errors)
	}

	return nil
}

// UpdateRoleReqMultiError is an error wrapping multiple validation errors
// returned by UpdateRoleReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateRoleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRoleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRoleReqMultiError) AllErrors() []error { return m }

// UpdateRoleReqValidationError is the validation error returned by
// UpdateRoleReq.Validate if the designated constraints aren't met.
type UpdateRoleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRoleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRoleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRoleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRoleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRoleReqValidationError) ErrorName() string { return "UpdateRoleReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRoleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRoleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRoleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRoleReqValidationError{}

// Validate checks the field values on SetRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetRolesForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetRolesForUserReqMultiError, or nil if none found.
func (m *SetRolesForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetRolesForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 1 || l > 255 {
		err := SetRolesForUserReqValidationError{
			field:  "Username",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRoles()) < 1 {
		err := SetRolesForUserReqValidationError{
			field:  "Roles",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SetRolesForUserReqMultiError(errors)
	}

	return nil
}

// SetRolesForUserReqMultiError is an error wrapping multiple validation errors
// returned by SetRolesForUserReq.ValidateAll() if the designated constraints
// aren't met.
type SetRolesForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetRolesForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetRolesForUserReqMultiError) AllErrors() []error { return m }

// SetRolesForUserReqValidationError is the validation error returned by
// SetRolesForUserReq.Validate if the designated constraints aren't met.
type SetRolesForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetRolesForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetRolesForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetRolesForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetRolesForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetRolesForUserReqValidationError) ErrorName() string {
	return "SetRolesForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetRolesForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetRolesForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetRolesForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetRolesForUserReqValidationError{}

// Validate checks the field values on GetRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRolesForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRolesForUserReqMultiError, or nil if none found.
func (m *GetRolesForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRolesForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 1 || l > 255 {
		err := GetRolesForUserReqValidationError{
			field:  "Username",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRolesForUserReqMultiError(errors)
	}

	return nil
}

// GetRolesForUserReqMultiError is an error wrapping multiple validation errors
// returned by GetRolesForUserReq.ValidateAll() if the designated constraints
// aren't met.
type GetRolesForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRolesForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRolesForUserReqMultiError) AllErrors() []error { return m }

// GetRolesForUserReqValidationError is the validation error returned by
// GetRolesForUserReq.Validate if the designated constraints aren't met.
type GetRolesForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRolesForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRolesForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRolesForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRolesForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRolesForUserReqValidationError) ErrorName() string {
	return "GetRolesForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetRolesForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRolesForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRolesForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRolesForUserReqValidationError{}

// Validate checks the field values on GetRolesForUserRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRolesForUserRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRolesForUserRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRolesForUserResMultiError, or nil if none found.
func (m *GetRolesForUserRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRolesForUserRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetRolesForUserResMultiError(errors)
	}

	return nil
}

// GetRolesForUserResMultiError is an error wrapping multiple validation errors
// returned by GetRolesForUserRes.ValidateAll() if the designated constraints
// aren't met.
type GetRolesForUserResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRolesForUserResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRolesForUserResMultiError) AllErrors() []error { return m }

// GetRolesForUserResValidationError is the validation error returned by
// GetRolesForUserRes.Validate if the designated constraints aren't met.
type GetRolesForUserResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRolesForUserResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRolesForUserResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRolesForUserResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRolesForUserResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRolesForUserResValidationError) ErrorName() string {
	return "GetRolesForUserResValidationError"
}

// Error satisfies the builtin error interface
func (e GetRolesForUserResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRolesForUserRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRolesForUserResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRolesForUserResValidationError{}

// Validate checks the field values on RoleNameReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleNameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleNameReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleNameReqMultiError, or
// nil if none found.
func (m *RoleNameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleNameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetRole()); l < 1 || l > 255 {
		err := RoleNameReqValidationError{
			field:  "Role",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RoleNameReqMultiError(errors)
	}

	return nil
}

// RoleNameReqMultiError is an error wrapping multiple validation errors
// returned by RoleNameReq.ValidateAll() if the designated constraints aren't met.
type RoleNameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleNameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleNameReqMultiError) AllErrors() []error { return m }

// RoleNameReqValidationError is the validation error returned by
// RoleNameReq.Validate if the designated constraints aren't met.
type RoleNameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleNameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleNameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleNameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleNameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleNameReqValidationError) ErrorName() string { return "RoleNameReqValidationError" }

// Error satisfies the builtin error interface
func (e RoleNameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleNameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleNameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleNameReqValidationError{}

// Validate checks the field values on GetUsersForRoleRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUsersForRoleRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUsersForRoleRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUsersForRoleResMultiError, or nil if none found.
func (m *GetUsersForRoleRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUsersForRoleRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetUsersForRoleResMultiError(errors)
	}

	return nil
}

// GetUsersForRoleResMultiError is an error wrapping multiple validation errors
// returned by GetUsersForRoleRes.ValidateAll() if the designated constraints
// aren't met.
type GetUsersForRoleResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUsersForRoleResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUsersForRoleResMultiError) AllErrors() []error { return m }

// GetUsersForRoleResValidationError is the validation error returned by
// GetUsersForRoleRes.Validate if the designated constraints aren't met.
type GetUsersForRoleResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUsersForRoleResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUsersForRoleResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUsersForRoleResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUsersForRoleResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUsersForRoleResValidationError) ErrorName() string {
	return "GetUsersForRoleResValidationError"
}

// Error satisfies the builtin error interface
func (e GetUsersForRoleResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUsersForRoleRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUsersForRoleResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUsersForRoleResValidationError{}

// Validate checks the field values on DeleteRoleForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRoleForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRoleForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRoleForUserReqMultiError, or nil if none found.
func (m *DeleteRoleForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRoleForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 1 || l > 255 {
		err := DeleteRoleForUserReqValidationError{
			field:  "Username",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRole()); l < 1 || l > 255 {
		err := DeleteRoleForUserReqValidationError{
			field:  "Role",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRoleForUserReqMultiError(errors)
	}

	return nil
}

// DeleteRoleForUserReqMultiError is an error wrapping multiple validation
// errors returned by DeleteRoleForUserReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteRoleForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRoleForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRoleForUserReqMultiError) AllErrors() []error { return m }

// DeleteRoleForUserReqValidationError is the validation error returned by
// DeleteRoleForUserReq.Validate if the designated constraints aren't met.
type DeleteRoleForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRoleForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRoleForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRoleForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRoleForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRoleForUserReqValidationError) ErrorName() string {
	return "DeleteRoleForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRoleForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRoleForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRoleForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRoleForUserReqValidationError{}

// Validate checks the field values on DeleteRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRolesForUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRolesForUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRolesForUserReqMultiError, or nil if none found.
func (m *DeleteRolesForUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRolesForUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 1 || l > 255 {
		err := DeleteRolesForUserReqValidationError{
			field:  "Username",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRolesForUserReqMultiError(errors)
	}

	return nil
}

// DeleteRolesForUserReqMultiError is an error wrapping multiple validation
// errors returned by DeleteRolesForUserReq.ValidateAll() if the designated
// constraints aren't met.
type DeleteRolesForUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRolesForUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRolesForUserReqMultiError) AllErrors() []error { return m }

// DeleteRolesForUserReqValidationError is the validation error returned by
// DeleteRolesForUserReq.Validate if the designated constraints aren't met.
type DeleteRolesForUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRolesForUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRolesForUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRolesForUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRolesForUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRolesForUserReqValidationError) ErrorName() string {
	return "DeleteRolesForUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRolesForUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRolesForUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRolesForUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRolesForUserReqValidationError{}

// Validate checks the field values on PolicyRules with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PolicyRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolicyRules with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PolicyRulesMultiError, or
// nil if none found.
func (m *PolicyRules) ValidateAll() error {
	return m.validate(true)
}

func (m *PolicyRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Method

	if len(errors) > 0 {
		return PolicyRulesMultiError(errors)
	}

	return nil
}

// PolicyRulesMultiError is an error wrapping multiple validation errors
// returned by PolicyRules.ValidateAll() if the designated constraints aren't met.
type PolicyRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyRulesMultiError) AllErrors() []error { return m }

// PolicyRulesValidationError is the validation error returned by
// PolicyRules.Validate if the designated constraints aren't met.
type PolicyRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyRulesValidationError) ErrorName() string { return "PolicyRulesValidationError" }

// Error satisfies the builtin error interface
func (e PolicyRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyRulesValidationError{}

// Validate checks the field values on UpdatePoliciesReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdatePoliciesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePoliciesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePoliciesReqMultiError, or nil if none found.
func (m *UpdatePoliciesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePoliciesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetRole()); l < 1 || l > 255 {
		err := UpdatePoliciesReqValidationError{
			field:  "Role",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetPolicyRules()) < 1 {
		err := UpdatePoliciesReqValidationError{
			field:  "PolicyRules",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPolicyRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdatePoliciesReqValidationError{
						field:  fmt.Sprintf("PolicyRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdatePoliciesReqValidationError{
						field:  fmt.Sprintf("PolicyRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdatePoliciesReqValidationError{
					field:  fmt.Sprintf("PolicyRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdatePoliciesReqMultiError(errors)
	}

	return nil
}

// UpdatePoliciesReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePoliciesReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePoliciesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePoliciesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePoliciesReqMultiError) AllErrors() []error { return m }

// UpdatePoliciesReqValidationError is the validation error returned by
// UpdatePoliciesReq.Validate if the designated constraints aren't met.
type UpdatePoliciesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePoliciesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePoliciesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePoliciesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePoliciesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePoliciesReqValidationError) ErrorName() string {
	return "UpdatePoliciesReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePoliciesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePoliciesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePoliciesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePoliciesReqValidationError{}

// Validate checks the field values on GetPoliciesRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPoliciesRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPoliciesRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPoliciesResMultiError,
// or nil if none found.
func (m *GetPoliciesRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPoliciesRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPolicyRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPoliciesResValidationError{
						field:  fmt.Sprintf("PolicyRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPoliciesResValidationError{
						field:  fmt.Sprintf("PolicyRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPoliciesResValidationError{
					field:  fmt.Sprintf("PolicyRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPoliciesResMultiError(errors)
	}

	return nil
}

// GetPoliciesResMultiError is an error wrapping multiple validation errors
// returned by GetPoliciesRes.ValidateAll() if the designated constraints
// aren't met.
type GetPoliciesResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPoliciesResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPoliciesResMultiError) AllErrors() []error { return m }

// GetPoliciesResValidationError is the validation error returned by
// GetPoliciesRes.Validate if the designated constraints aren't met.
type GetPoliciesResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPoliciesResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPoliciesResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPoliciesResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPoliciesResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPoliciesResValidationError) ErrorName() string { return "GetPoliciesResValidationError" }

// Error satisfies the builtin error interface
func (e GetPoliciesResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPoliciesRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPoliciesResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPoliciesResValidationError{}

// Validate checks the field values on Api with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Api) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Api with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ApiMultiError, or nil if none found.
func (m *Api) ValidateAll() error {
	return m.validate(true)
}

func (m *Api) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Group

	// no validation rules for Method

	// no validation rules for Path

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return ApiMultiError(errors)
	}

	return nil
}

// ApiMultiError is an error wrapping multiple validation errors returned by
// Api.ValidateAll() if the designated constraints aren't met.
type ApiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApiMultiError) AllErrors() []error { return m }

// ApiValidationError is the validation error returned by Api.Validate if the
// designated constraints aren't met.
type ApiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApiValidationError) ErrorName() string { return "ApiValidationError" }

// Error satisfies the builtin error interface
func (e ApiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApiValidationError{}

// Validate checks the field values on GetApiListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetApiListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetApiListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetApiListReqMultiError, or
// nil if none found.
func (m *GetApiListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetApiListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() <= 0 {
		err := GetApiListReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() <= 0 {
		err := GetApiListReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Group

	// no validation rules for Method

	// no validation rules for Path

	if len(errors) > 0 {
		return GetApiListReqMultiError(errors)
	}

	return nil
}

// GetApiListReqMultiError is an error wrapping multiple validation errors
// returned by GetApiListReq.ValidateAll() if the designated constraints
// aren't met.
type GetApiListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetApiListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetApiListReqMultiError) AllErrors() []error { return m }

// GetApiListReqValidationError is the validation error returned by
// GetApiListReq.Validate if the designated constraints aren't met.
type GetApiListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetApiListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetApiListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetApiListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetApiListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetApiListReqValidationError) ErrorName() string { return "GetApiListReqValidationError" }

// Error satisfies the builtin error interface
func (e GetApiListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetApiListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetApiListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetApiListReqValidationError{}

// Validate checks the field values on GetApiAllRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetApiAllRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetApiAllRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetApiAllResMultiError, or
// nil if none found.
func (m *GetApiAllRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetApiAllRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetApiAllResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetApiAllResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetApiAllResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetApiAllResMultiError(errors)
	}

	return nil
}

// GetApiAllResMultiError is an error wrapping multiple validation errors
// returned by GetApiAllRes.ValidateAll() if the designated constraints aren't met.
type GetApiAllResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetApiAllResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetApiAllResMultiError) AllErrors() []error { return m }

// GetApiAllResValidationError is the validation error returned by
// GetApiAllRes.Validate if the designated constraints aren't met.
type GetApiAllResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetApiAllResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetApiAllResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetApiAllResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetApiAllResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetApiAllResValidationError) ErrorName() string { return "GetApiAllResValidationError" }

// Error satisfies the builtin error interface
func (e GetApiAllResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetApiAllRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetApiAllResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetApiAllResValidationError{}

// Validate checks the field values on GetApiListRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetApiListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetApiListRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetApiListResMultiError, or
// nil if none found.
func (m *GetApiListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetApiListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetApiListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetApiListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetApiListResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetApiListResMultiError(errors)
	}

	return nil
}

// GetApiListResMultiError is an error wrapping multiple validation errors
// returned by GetApiListRes.ValidateAll() if the designated constraints
// aren't met.
type GetApiListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetApiListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetApiListResMultiError) AllErrors() []error { return m }

// GetApiListResValidationError is the validation error returned by
// GetApiListRes.Validate if the designated constraints aren't met.
type GetApiListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetApiListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetApiListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetApiListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetApiListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetApiListResValidationError) ErrorName() string { return "GetApiListResValidationError" }

// Error satisfies the builtin error interface
func (e GetApiListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetApiListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetApiListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetApiListResValidationError{}

// Validate checks the field values on CreateApiReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateApiReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateApiReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateApiReqMultiError, or
// nil if none found.
func (m *CreateApiReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateApiReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateApiReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetGroup()); l < 1 || l > 255 {
		err := CreateApiReqValidationError{
			field:  "Group",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetMethod()); l < 1 || l > 255 {
		err := CreateApiReqValidationError{
			field:  "Method",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 255 {
		err := CreateApiReqValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateApiReqMultiError(errors)
	}

	return nil
}

// CreateApiReqMultiError is an error wrapping multiple validation errors
// returned by CreateApiReq.ValidateAll() if the designated constraints aren't met.
type CreateApiReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateApiReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateApiReqMultiError) AllErrors() []error { return m }

// CreateApiReqValidationError is the validation error returned by
// CreateApiReq.Validate if the designated constraints aren't met.
type CreateApiReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateApiReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateApiReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateApiReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateApiReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateApiReqValidationError) ErrorName() string { return "CreateApiReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateApiReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateApiReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateApiReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateApiReqValidationError{}

// Validate checks the field values on UpdateApiReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateApiReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateApiReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateApiReqMultiError, or
// nil if none found.
func (m *UpdateApiReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateApiReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateApiReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := UpdateApiReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetGroup()); l < 1 || l > 255 {
		err := UpdateApiReqValidationError{
			field:  "Group",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetMethod()); l < 1 || l > 255 {
		err := UpdateApiReqValidationError{
			field:  "Method",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 255 {
		err := UpdateApiReqValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateApiReqMultiError(errors)
	}

	return nil
}

// UpdateApiReqMultiError is an error wrapping multiple validation errors
// returned by UpdateApiReq.ValidateAll() if the designated constraints aren't met.
type UpdateApiReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateApiReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateApiReqMultiError) AllErrors() []error { return m }

// UpdateApiReqValidationError is the validation error returned by
// UpdateApiReq.Validate if the designated constraints aren't met.
type UpdateApiReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateApiReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateApiReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateApiReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateApiReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateApiReqValidationError) ErrorName() string { return "UpdateApiReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateApiReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateApiReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateApiReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateApiReqValidationError{}

// Validate checks the field values on GetMenuTreeRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMenuTreeRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMenuTreeRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMenuTreeResMultiError,
// or nil if none found.
func (m *GetMenuTreeRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMenuTreeRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMenuTreeResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMenuTreeResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMenuTreeResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetMenuTreeResMultiError(errors)
	}

	return nil
}

// GetMenuTreeResMultiError is an error wrapping multiple validation errors
// returned by GetMenuTreeRes.ValidateAll() if the designated constraints
// aren't met.
type GetMenuTreeResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMenuTreeResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMenuTreeResMultiError) AllErrors() []error { return m }

// GetMenuTreeResValidationError is the validation error returned by
// GetMenuTreeRes.Validate if the designated constraints aren't met.
type GetMenuTreeResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMenuTreeResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMenuTreeResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMenuTreeResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMenuTreeResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMenuTreeResValidationError) ErrorName() string { return "GetMenuTreeResValidationError" }

// Error satisfies the builtin error interface
func (e GetMenuTreeResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMenuTreeRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMenuTreeResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMenuTreeResValidationError{}

// Validate checks the field values on Menu with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MenuMultiError, or nil if none found.
func (m *Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ParentId

	// no validation rules for Path

	// no validation rules for Name

	// no validation rules for Hidden

	// no validation rules for Component

	// no validation rules for Sort

	// no validation rules for Title

	// no validation rules for Icon

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMenuBtns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("MenuBtns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("MenuBtns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("MenuBtns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ParentIds

	if len(errors) > 0 {
		return MenuMultiError(errors)
	}

	return nil
}

// MenuMultiError is an error wrapping multiple validation errors returned by
// Menu.ValidateAll() if the designated constraints aren't met.
type MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuMultiError) AllErrors() []error { return m }

// MenuValidationError is the validation error returned by Menu.Validate if the
// designated constraints aren't met.
type MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuValidationError) ErrorName() string { return "MenuValidationError" }

// Error satisfies the builtin error interface
func (e MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuValidationError{}

// Validate checks the field values on MenuBtn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuBtn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuBtn with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MenuBtnMultiError, or nil if none found.
func (m *MenuBtn) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuBtn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MenuId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Identifier

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return MenuBtnMultiError(errors)
	}

	return nil
}

// MenuBtnMultiError is an error wrapping multiple validation errors returned
// by MenuBtn.ValidateAll() if the designated constraints aren't met.
type MenuBtnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuBtnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuBtnMultiError) AllErrors() []error { return m }

// MenuBtnValidationError is the validation error returned by MenuBtn.Validate
// if the designated constraints aren't met.
type MenuBtnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuBtnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuBtnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuBtnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuBtnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuBtnValidationError) ErrorName() string { return "MenuBtnValidationError" }

// Error satisfies the builtin error interface
func (e MenuBtnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuBtn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuBtnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuBtnValidationError{}

// Validate checks the field values on CreateMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateMenuReqMultiError, or
// nil if none found.
func (m *CreateMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParentId

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 255 {
		err := CreateMenuReqValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := CreateMenuReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Hidden

	if l := utf8.RuneCountInString(m.GetComponent()); l < 1 || l > 255 {
		err := CreateMenuReqValidationError{
			field:  "Component",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() <= 0 {
		err := CreateMenuReqValidationError{
			field:  "Sort",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 255 {
		err := CreateMenuReqValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetIcon()); l < 1 || l > 255 {
		err := CreateMenuReqValidationError{
			field:  "Icon",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMenuBtns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("MenuBtns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateMenuReqValidationError{
						field:  fmt.Sprintf("MenuBtns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateMenuReqValidationError{
					field:  fmt.Sprintf("MenuBtns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if l := utf8.RuneCountInString(m.GetParentIds()); l < 1 || l > 255 {
		err := CreateMenuReqValidationError{
			field:  "ParentIds",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateMenuReqMultiError(errors)
	}

	return nil
}

// CreateMenuReqMultiError is an error wrapping multiple validation errors
// returned by CreateMenuReq.ValidateAll() if the designated constraints
// aren't met.
type CreateMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMenuReqMultiError) AllErrors() []error { return m }

// CreateMenuReqValidationError is the validation error returned by
// CreateMenuReq.Validate if the designated constraints aren't met.
type CreateMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMenuReqValidationError) ErrorName() string { return "CreateMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMenuReqValidationError{}

// Validate checks the field values on UpdateMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateMenuReqMultiError, or
// nil if none found.
func (m *UpdateMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateMenuReqValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ParentId

	if l := utf8.RuneCountInString(m.GetPath()); l < 1 || l > 255 {
		err := UpdateMenuReqValidationError{
			field:  "Path",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := UpdateMenuReqValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Hidden

	if l := utf8.RuneCountInString(m.GetComponent()); l < 1 || l > 255 {
		err := UpdateMenuReqValidationError{
			field:  "Component",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSort() <= 0 {
		err := UpdateMenuReqValidationError{
			field:  "Sort",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTitle()); l < 1 || l > 255 {
		err := UpdateMenuReqValidationError{
			field:  "Title",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetIcon()); l < 1 || l > 255 {
		err := UpdateMenuReqValidationError{
			field:  "Icon",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMenuBtns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateMenuReqValidationError{
						field:  fmt.Sprintf("MenuBtns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateMenuReqValidationError{
						field:  fmt.Sprintf("MenuBtns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateMenuReqValidationError{
					field:  fmt.Sprintf("MenuBtns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if l := utf8.RuneCountInString(m.GetParentIds()); l < 1 || l > 255 {
		err := UpdateMenuReqValidationError{
			field:  "ParentIds",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateMenuReqMultiError(errors)
	}

	return nil
}

// UpdateMenuReqMultiError is an error wrapping multiple validation errors
// returned by UpdateMenuReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMenuReqMultiError) AllErrors() []error { return m }

// UpdateMenuReqValidationError is the validation error returned by
// UpdateMenuReq.Validate if the designated constraints aren't met.
type UpdateMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMenuReqValidationError) ErrorName() string { return "UpdateMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMenuReqValidationError{}

// Validate checks the field values on SetRoleMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetRoleMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetRoleMenuReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetRoleMenuReqMultiError,
// or nil if none found.
func (m *SetRoleMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetRoleMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() <= 0 {
		err := SetRoleMenuReqValidationError{
			field:  "RoleId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMenuIds()) < 1 {
		err := SetRoleMenuReqValidationError{
			field:  "MenuIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SetRoleMenuReqMultiError(errors)
	}

	return nil
}

// SetRoleMenuReqMultiError is an error wrapping multiple validation errors
// returned by SetRoleMenuReq.ValidateAll() if the designated constraints
// aren't met.
type SetRoleMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetRoleMenuReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetRoleMenuReqMultiError) AllErrors() []error { return m }

// SetRoleMenuReqValidationError is the validation error returned by
// SetRoleMenuReq.Validate if the designated constraints aren't met.
type SetRoleMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetRoleMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetRoleMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetRoleMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetRoleMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetRoleMenuReqValidationError) ErrorName() string { return "SetRoleMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e SetRoleMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetRoleMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetRoleMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetRoleMenuReqValidationError{}

// Validate checks the field values on GetRoleMenuBtnReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRoleMenuBtnReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleMenuBtnReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRoleMenuBtnReqMultiError, or nil if none found.
func (m *GetRoleMenuBtnReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleMenuBtnReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleId

	// no validation rules for RoleName

	// no validation rules for MenuId

	if len(errors) > 0 {
		return GetRoleMenuBtnReqMultiError(errors)
	}

	return nil
}

// GetRoleMenuBtnReqMultiError is an error wrapping multiple validation errors
// returned by GetRoleMenuBtnReq.ValidateAll() if the designated constraints
// aren't met.
type GetRoleMenuBtnReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleMenuBtnReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleMenuBtnReqMultiError) AllErrors() []error { return m }

// GetRoleMenuBtnReqValidationError is the validation error returned by
// GetRoleMenuBtnReq.Validate if the designated constraints aren't met.
type GetRoleMenuBtnReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleMenuBtnReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleMenuBtnReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleMenuBtnReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleMenuBtnReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleMenuBtnReqValidationError) ErrorName() string {
	return "GetRoleMenuBtnReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetRoleMenuBtnReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleMenuBtnReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleMenuBtnReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleMenuBtnReqValidationError{}

// Validate checks the field values on GetRoleMenuBtnRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRoleMenuBtnRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRoleMenuBtnRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRoleMenuBtnResMultiError, or nil if none found.
func (m *GetRoleMenuBtnRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRoleMenuBtnRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetRoleMenuBtnResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetRoleMenuBtnResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetRoleMenuBtnResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetRoleMenuBtnResMultiError(errors)
	}

	return nil
}

// GetRoleMenuBtnResMultiError is an error wrapping multiple validation errors
// returned by GetRoleMenuBtnRes.ValidateAll() if the designated constraints
// aren't met.
type GetRoleMenuBtnResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRoleMenuBtnResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRoleMenuBtnResMultiError) AllErrors() []error { return m }

// GetRoleMenuBtnResValidationError is the validation error returned by
// GetRoleMenuBtnRes.Validate if the designated constraints aren't met.
type GetRoleMenuBtnResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRoleMenuBtnResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRoleMenuBtnResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRoleMenuBtnResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRoleMenuBtnResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRoleMenuBtnResValidationError) ErrorName() string {
	return "GetRoleMenuBtnResValidationError"
}

// Error satisfies the builtin error interface
func (e GetRoleMenuBtnResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRoleMenuBtnRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRoleMenuBtnResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRoleMenuBtnResValidationError{}

// Validate checks the field values on SetRoleMenuBtnReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetRoleMenuBtnReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetRoleMenuBtnReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetRoleMenuBtnReqMultiError, or nil if none found.
func (m *SetRoleMenuBtnReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetRoleMenuBtnReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRoleId() <= 0 {
		err := SetRoleMenuBtnReqValidationError{
			field:  "RoleId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMenuId() <= 0 {
		err := SetRoleMenuBtnReqValidationError{
			field:  "MenuId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMenuBtnIds()) < 1 {
		err := SetRoleMenuBtnReqValidationError{
			field:  "MenuBtnIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SetRoleMenuBtnReqMultiError(errors)
	}

	return nil
}

// SetRoleMenuBtnReqMultiError is an error wrapping multiple validation errors
// returned by SetRoleMenuBtnReq.ValidateAll() if the designated constraints
// aren't met.
type SetRoleMenuBtnReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetRoleMenuBtnReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetRoleMenuBtnReqMultiError) AllErrors() []error { return m }

// SetRoleMenuBtnReqValidationError is the validation error returned by
// SetRoleMenuBtnReq.Validate if the designated constraints aren't met.
type SetRoleMenuBtnReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetRoleMenuBtnReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetRoleMenuBtnReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetRoleMenuBtnReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetRoleMenuBtnReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetRoleMenuBtnReqValidationError) ErrorName() string {
	return "SetRoleMenuBtnReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetRoleMenuBtnReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetRoleMenuBtnReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetRoleMenuBtnReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetRoleMenuBtnReqValidationError{}

// Validate checks the field values on GetApiLogListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetApiLogListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetApiLogListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetApiLogListReqMultiError, or nil if none found.
func (m *GetApiLogListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetApiLogListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPage() <= 0 {
		err := GetApiLogListReqValidationError{
			field:  "Page",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() <= 0 {
		err := GetApiLogListReqValidationError{
			field:  "PageSize",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for Role

	// no validation rules for Operation

	// no validation rules for Ip

	// no validation rules for TraceId

	if len(errors) > 0 {
		return GetApiLogListReqMultiError(errors)
	}

	return nil
}

// GetApiLogListReqMultiError is an error wrapping multiple validation errors
// returned by GetApiLogListReq.ValidateAll() if the designated constraints
// aren't met.
type GetApiLogListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetApiLogListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetApiLogListReqMultiError) AllErrors() []error { return m }

// GetApiLogListReqValidationError is the validation error returned by
// GetApiLogListReq.Validate if the designated constraints aren't met.
type GetApiLogListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetApiLogListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetApiLogListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetApiLogListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetApiLogListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetApiLogListReqValidationError) ErrorName() string { return "GetApiLogListReqValidationError" }

// Error satisfies the builtin error interface
func (e GetApiLogListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetApiLogListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetApiLogListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetApiLogListReqValidationError{}

// Validate checks the field values on ApiLog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ApiLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApiLog with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ApiLogMultiError, or nil if none found.
func (m *ApiLog) ValidateAll() error {
	return m.validate(true)
}

func (m *ApiLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TraceId

	// no validation rules for Component

	// no validation rules for Operation

	// no validation rules for UserId

	// no validation rules for Method

	// no validation rules for Path

	// no validation rules for Request

	// no validation rules for Code

	// no validation rules for Reason

	// no validation rules for Ip

	// no validation rules for CreatedAt

	// no validation rules for Domain

	// no validation rules for Name

	// no validation rules for Latency

	// no validation rules for Username

	// no validation rules for Role

	if len(errors) > 0 {
		return ApiLogMultiError(errors)
	}

	return nil
}

// ApiLogMultiError is an error wrapping multiple validation errors returned by
// ApiLog.ValidateAll() if the designated constraints aren't met.
type ApiLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApiLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApiLogMultiError) AllErrors() []error { return m }

// ApiLogValidationError is the validation error returned by ApiLog.Validate if
// the designated constraints aren't met.
type ApiLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApiLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApiLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApiLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApiLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApiLogValidationError) ErrorName() string { return "ApiLogValidationError" }

// Error satisfies the builtin error interface
func (e ApiLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApiLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApiLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApiLogValidationError{}

// Validate checks the field values on GetApiLogListRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetApiLogListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetApiLogListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetApiLogListResMultiError, or nil if none found.
func (m *GetApiLogListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetApiLogListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetApiLogListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetApiLogListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetApiLogListResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetApiLogListResMultiError(errors)
	}

	return nil
}

// GetApiLogListResMultiError is an error wrapping multiple validation errors
// returned by GetApiLogListRes.ValidateAll() if the designated constraints
// aren't met.
type GetApiLogListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetApiLogListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetApiLogListResMultiError) AllErrors() []error { return m }

// GetApiLogListResValidationError is the validation error returned by
// GetApiLogListRes.Validate if the designated constraints aren't met.
type GetApiLogListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetApiLogListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetApiLogListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetApiLogListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetApiLogListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetApiLogListResValidationError) ErrorName() string { return "GetApiLogListResValidationError" }

// Error satisfies the builtin error interface
func (e GetApiLogListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetApiLogListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetApiLogListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetApiLogListResValidationError{}

// Validate checks the field values on OssStsTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OssStsTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OssStsTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OssStsTokenResponseMultiError, or nil if none found.
func (m *OssStsTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OssStsTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessKey

	// no validation rules for AccessSecret

	// no validation rules for Expiration

	// no validation rules for SecurityToken

	// no validation rules for EndPoint

	// no validation rules for BucketName

	// no validation rules for Region

	// no validation rules for Url

	if len(errors) > 0 {
		return OssStsTokenResponseMultiError(errors)
	}

	return nil
}

// OssStsTokenResponseMultiError is an error wrapping multiple validation
// errors returned by OssStsTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type OssStsTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OssStsTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OssStsTokenResponseMultiError) AllErrors() []error { return m }

// OssStsTokenResponseValidationError is the validation error returned by
// OssStsTokenResponse.Validate if the designated constraints aren't met.
type OssStsTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OssStsTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OssStsTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OssStsTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OssStsTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OssStsTokenResponseValidationError) ErrorName() string {
	return "OssStsTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OssStsTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOssStsTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OssStsTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OssStsTokenResponseValidationError{}

// Validate checks the field values on UploadFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UploadFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UploadFileRequestMultiError, or nil if none found.
func (m *UploadFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetFileName()); l < 1 || l > 255 {
		err := UploadFileRequestValidationError{
			field:  "FileName",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UploadFileRequest_FileType_InLookup[m.GetFileType()]; !ok {
		err := UploadFileRequestValidationError{
			field:  "FileType",
			reason: "value must be in list [jpg png jpeg]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetContent()) < 1 {
		err := UploadFileRequestValidationError{
			field:  "Content",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UploadFileRequestMultiError(errors)
	}

	return nil
}

// UploadFileRequestMultiError is an error wrapping multiple validation errors
// returned by UploadFileRequest.ValidateAll() if the designated constraints
// aren't met.
type UploadFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadFileRequestMultiError) AllErrors() []error { return m }

// UploadFileRequestValidationError is the validation error returned by
// UploadFileRequest.Validate if the designated constraints aren't met.
type UploadFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadFileRequestValidationError) ErrorName() string {
	return "UploadFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UploadFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadFileRequestValidationError{}

var _UploadFileRequest_FileType_InLookup = map[string]struct{}{
	"jpg":  {},
	"png":  {},
	"jpeg": {},
}

// Validate checks the field values on UploadFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UploadFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UploadFileResponseMultiError, or nil if none found.
func (m *UploadFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return UploadFileResponseMultiError(errors)
	}

	return nil
}

// UploadFileResponseMultiError is an error wrapping multiple validation errors
// returned by UploadFileResponse.ValidateAll() if the designated constraints
// aren't met.
type UploadFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadFileResponseMultiError) AllErrors() []error { return m }

// UploadFileResponseValidationError is the validation error returned by
// UploadFileResponse.Validate if the designated constraints aren't met.
type UploadFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadFileResponseValidationError) ErrorName() string {
	return "UploadFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UploadFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadFileResponseValidationError{}

// Validate checks the field values on CreateGptMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateGptMessageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateGptMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateGptMessageReqMultiError, or nil if none found.
func (m *CreateGptMessageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateGptMessageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _CreateGptMessageReq_Model_InLookup[m.GetModel()]; !ok {
		err := CreateGptMessageReqValidationError{
			field:  "Model",
			reason: "value must be in list [gpt-3.5-turbo]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateGptMessageReqValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateGptMessageReqValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateGptMessageReqValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateGptMessageReqMultiError(errors)
	}

	return nil
}

// CreateGptMessageReqMultiError is an error wrapping multiple validation
// errors returned by CreateGptMessageReq.ValidateAll() if the designated
// constraints aren't met.
type CreateGptMessageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateGptMessageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateGptMessageReqMultiError) AllErrors() []error { return m }

// CreateGptMessageReqValidationError is the validation error returned by
// CreateGptMessageReq.Validate if the designated constraints aren't met.
type CreateGptMessageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateGptMessageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateGptMessageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateGptMessageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateGptMessageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateGptMessageReqValidationError) ErrorName() string {
	return "CreateGptMessageReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateGptMessageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateGptMessageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateGptMessageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateGptMessageReqValidationError{}

var _CreateGptMessageReq_Model_InLookup = map[string]struct{}{
	"gpt-3.5-turbo": {},
}

// Validate checks the field values on ChatgptMessageReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChatgptMessageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatgptMessageReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChatgptMessageReqMultiError, or nil if none found.
func (m *ChatgptMessageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatgptMessageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	// no validation rules for Content

	if len(errors) > 0 {
		return ChatgptMessageReqMultiError(errors)
	}

	return nil
}

// ChatgptMessageReqMultiError is an error wrapping multiple validation errors
// returned by ChatgptMessageReq.ValidateAll() if the designated constraints
// aren't met.
type ChatgptMessageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatgptMessageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatgptMessageReqMultiError) AllErrors() []error { return m }

// ChatgptMessageReqValidationError is the validation error returned by
// ChatgptMessageReq.Validate if the designated constraints aren't met.
type ChatgptMessageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatgptMessageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatgptMessageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatgptMessageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatgptMessageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatgptMessageReqValidationError) ErrorName() string {
	return "ChatgptMessageReqValidationError"
}

// Error satisfies the builtin error interface
func (e ChatgptMessageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatgptMessageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatgptMessageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatgptMessageReqValidationError{}

// Validate checks the field values on CreateGptMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateGptMessageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateGptMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateGptMessageResMultiError, or nil if none found.
func (m *CreateGptMessageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateGptMessageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Object

	// no validation rules for Created

	// no validation rules for Model

	if all {
		switch v := interface{}(m.GetUsage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateGptMessageResValidationError{
					field:  "Usage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateGptMessageResValidationError{
					field:  "Usage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateGptMessageResValidationError{
				field:  "Usage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateGptMessageResValidationError{
						field:  fmt.Sprintf("Choices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateGptMessageResValidationError{
						field:  fmt.Sprintf("Choices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateGptMessageResValidationError{
					field:  fmt.Sprintf("Choices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateGptMessageResValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateGptMessageResValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateGptMessageResValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateGptMessageResMultiError(errors)
	}

	return nil
}

// CreateGptMessageResMultiError is an error wrapping multiple validation
// errors returned by CreateGptMessageRes.ValidateAll() if the designated
// constraints aren't met.
type CreateGptMessageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateGptMessageResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateGptMessageResMultiError) AllErrors() []error { return m }

// CreateGptMessageResValidationError is the validation error returned by
// CreateGptMessageRes.Validate if the designated constraints aren't met.
type CreateGptMessageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateGptMessageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateGptMessageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateGptMessageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateGptMessageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateGptMessageResValidationError) ErrorName() string {
	return "CreateGptMessageResValidationError"
}

// Error satisfies the builtin error interface
func (e CreateGptMessageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateGptMessageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateGptMessageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateGptMessageResValidationError{}

// Validate checks the field values on ChatgptUsageRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChatgptUsageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatgptUsageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChatgptUsageResMultiError, or nil if none found.
func (m *ChatgptUsageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatgptUsageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PromptTokes

	// no validation rules for CompletionTokes

	// no validation rules for TotalTokens

	if len(errors) > 0 {
		return ChatgptUsageResMultiError(errors)
	}

	return nil
}

// ChatgptUsageResMultiError is an error wrapping multiple validation errors
// returned by ChatgptUsageRes.ValidateAll() if the designated constraints
// aren't met.
type ChatgptUsageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatgptUsageResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatgptUsageResMultiError) AllErrors() []error { return m }

// ChatgptUsageResValidationError is the validation error returned by
// ChatgptUsageRes.Validate if the designated constraints aren't met.
type ChatgptUsageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatgptUsageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatgptUsageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatgptUsageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatgptUsageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatgptUsageResValidationError) ErrorName() string { return "ChatgptUsageResValidationError" }

// Error satisfies the builtin error interface
func (e ChatgptUsageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatgptUsageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatgptUsageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatgptUsageResValidationError{}

// Validate checks the field values on ChatgptChoicesRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChatgptChoicesRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatgptChoicesRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChatgptChoicesResMultiError, or nil if none found.
func (m *ChatgptChoicesRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatgptChoicesRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChatgptChoicesResValidationError{
						field:  fmt.Sprintf("Choices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChatgptChoicesResValidationError{
						field:  fmt.Sprintf("Choices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChatgptChoicesResValidationError{
					field:  fmt.Sprintf("Choices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChatgptChoicesResMultiError(errors)
	}

	return nil
}

// ChatgptChoicesResMultiError is an error wrapping multiple validation errors
// returned by ChatgptChoicesRes.ValidateAll() if the designated constraints
// aren't met.
type ChatgptChoicesResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatgptChoicesResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatgptChoicesResMultiError) AllErrors() []error { return m }

// ChatgptChoicesResValidationError is the validation error returned by
// ChatgptChoicesRes.Validate if the designated constraints aren't met.
type ChatgptChoicesResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatgptChoicesResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatgptChoicesResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatgptChoicesResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatgptChoicesResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatgptChoicesResValidationError) ErrorName() string {
	return "ChatgptChoicesResValidationError"
}

// Error satisfies the builtin error interface
func (e ChatgptChoicesResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatgptChoicesRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatgptChoicesResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatgptChoicesResValidationError{}

// Validate checks the field values on ChatgptChoiceRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChatgptChoiceRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatgptChoiceRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChatgptChoiceResMultiError, or nil if none found.
func (m *ChatgptChoiceRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatgptChoiceRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FinishReason

	// no validation rules for Index

	if all {
		switch v := interface{}(m.GetMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChatgptChoiceResValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChatgptChoiceResValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChatgptChoiceResValidationError{
				field:  "Message",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChatgptChoiceResMultiError(errors)
	}

	return nil
}

// ChatgptChoiceResMultiError is an error wrapping multiple validation errors
// returned by ChatgptChoiceRes.ValidateAll() if the designated constraints
// aren't met.
type ChatgptChoiceResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatgptChoiceResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatgptChoiceResMultiError) AllErrors() []error { return m }

// ChatgptChoiceResValidationError is the validation error returned by
// ChatgptChoiceRes.Validate if the designated constraints aren't met.
type ChatgptChoiceResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatgptChoiceResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatgptChoiceResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatgptChoiceResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatgptChoiceResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatgptChoiceResValidationError) ErrorName() string { return "ChatgptChoiceResValidationError" }

// Error satisfies the builtin error interface
func (e ChatgptChoiceResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatgptChoiceRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatgptChoiceResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatgptChoiceResValidationError{}

// Validate checks the field values on ChatgptChoiceMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChatgptChoiceMessageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatgptChoiceMessageRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChatgptChoiceMessageResMultiError, or nil if none found.
func (m *ChatgptChoiceMessageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatgptChoiceMessageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	// no validation rules for Content

	if len(errors) > 0 {
		return ChatgptChoiceMessageResMultiError(errors)
	}

	return nil
}

// ChatgptChoiceMessageResMultiError is an error wrapping multiple validation
// errors returned by ChatgptChoiceMessageRes.ValidateAll() if the designated
// constraints aren't met.
type ChatgptChoiceMessageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatgptChoiceMessageResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatgptChoiceMessageResMultiError) AllErrors() []error { return m }

// ChatgptChoiceMessageResValidationError is the validation error returned by
// ChatgptChoiceMessageRes.Validate if the designated constraints aren't met.
type ChatgptChoiceMessageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatgptChoiceMessageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatgptChoiceMessageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatgptChoiceMessageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatgptChoiceMessageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatgptChoiceMessageResValidationError) ErrorName() string {
	return "ChatgptChoiceMessageResValidationError"
}

// Error satisfies the builtin error interface
func (e ChatgptChoiceMessageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatgptChoiceMessageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatgptChoiceMessageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatgptChoiceMessageResValidationError{}

// Validate checks the field values on ErrorMessageRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ErrorMessageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorMessageRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErrorMessageResMultiError, or nil if none found.
func (m *ErrorMessageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorMessageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ErrorMessageResMultiError(errors)
	}

	return nil
}

// ErrorMessageResMultiError is an error wrapping multiple validation errors
// returned by ErrorMessageRes.ValidateAll() if the designated constraints
// aren't met.
type ErrorMessageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorMessageResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorMessageResMultiError) AllErrors() []error { return m }

// ErrorMessageResValidationError is the validation error returned by
// ErrorMessageRes.Validate if the designated constraints aren't met.
type ErrorMessageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorMessageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorMessageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorMessageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorMessageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorMessageResValidationError) ErrorName() string { return "ErrorMessageResValidationError" }

// Error satisfies the builtin error interface
func (e ErrorMessageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorMessageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorMessageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorMessageResValidationError{}
